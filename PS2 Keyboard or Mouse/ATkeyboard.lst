0001   0000             ; -----------------------------------------------------------------------------
0002   0000             ;
0003   0000             ; AT Keyboard support on SPI2C
0004   0000             ;
0005   0000             ; -----------------------------------------------------------------------------
0006   0000             
0007   0000             
0008   0000             #include "C:/Users/user/OneDrive/TEC-1/SC-1/TMON/scm18_include.asm"
0001+  0000             ;--------------------------------------------
0002+  0000             ; S O U T H E R N   C R O S S   M O N I T O R
0003+  0000             ;--------------------------------------------
0004+  0000             ;
0005+  0000             ;  MONITOR DEFINITIONS FILE 
0006+  0000             ;  Version 1.8
0007+  0000             ;
0008+  0000             ; WRITTEN BY CRAIG R. S. JONES
0009+  0000             ; MELBOURNE, AUSTRALIA.
0010+  0000             ;
0011+  0000             ;---------------
0012+  0000             ; RAM MEMORY MAP
0013+  0000             ;---------------
0014+  0000             BOTRAM	.EQU	2000H	;BOTTOM OF SRAM
0015+  0000             TOPRAM	.EQU	3FFFH	;TOP OF SRAM
0016+  0000             ;
0017+  0000             VARBLS	.EQU	TOPRAM-0FFH	;MONITOR VARIABLES
0018+  0000             BUFFER	.EQU	VARBLS-0100H	;GENERAL PURPOSE BUFFER AREA
0019+  0000             ISTACK	.EQU	BUFFER - 0200H	;INITIAL MONITOR STACK
0020+  0000             ;
0021+  0000             RAMEND	.EQU	ISTACK-0400H	;END OF USER RAM
0022+  0000             RAMSRT	.EQU	BOTRAM	;START OF USER RAM
0023+  0000             ;
0024+  0000             ; BIT BANG BAUD RATE CONSTANTS
0025+  0000             ;
0026+  0000             B300	.EQU	0220H	;300 BAUD
0027+  0000             B1200	.EQU	0080H	;1200 BAUD
0028+  0000             B2400	.EQU	003FH	;2400 BAUD
0029+  0000             B4800	.EQU	001BH	;4800 BAUD
0030+  0000             B9600	.EQU	000BH	;9600 BAUD
0031+  0000             ;
0032+  0000             ; KEY CODES
0033+  0000             ;
0034+  0000             KEYFN	.EQU	10H	;FN OR GO KEY
0035+  0000             KEYAD	.EQU	11H	;ADDRESS KEY
0036+  0000             KEYINC	.EQU	12H	;PLUS KEY
0037+  0000             KEYDEC	.EQU	13H	;MINUS KEY
0038+  0000             ;-------------------------
0039+  0000             ; MONITOR GLOBAL VARIABLES
0040+  0000             ;-------------------------
0041+  0000             ;
0042+  3F00             	.ORG	VARBLS
0043+  3F00             ;
0044+  3F00             ;SERIAL MONITOR VARIABLES
0045+  3F00             ;
0046+  3F00             VARIDX	.BLOCK	16	;RESERVE SOME SPACE FOR INDEXED VARIABLES (SEE INTELH)
0047+  3F10             SPSAVE	.BLOCK	2	;SAVE THE STACK POINTER
0048+  3F12             ADDR	.BLOCK	2	;THE ADDRESS
0049+  3F14             DATA	.BLOCK	1	;THE DATA
0050+  3F15             ;
0051+  3F15             FUNTBL	.BLOCK	 2	;FN TABLE ADDRESS
0052+  3F17             ;
0053+  3F17             ; DALLAS SMARTWATCH REGISTERS
0054+  3F17             ;
0055+  3F17             CALMDE	.BLOCK	2	;CALENDAR MODE
0056+  3F19             SWREG0	.BLOCK	1	;10THS, 100THS
0057+  3F1A             SWREG1	.BLOCK	1	;SECONDS
0058+  3F1B             SWREG2	.BLOCK	1	;MINUTES
0059+  3F1C             SWREG3	.BLOCK	1	;HOURS
0060+  3F1D             SWREG4	.BLOCK	1	;DAY
0061+  3F1E             SWREG5	.BLOCK	1	;DATE
0062+  3F1F             SWREG6	.BLOCK	1	;MONTH
0063+  3F20             SWREG7	.BLOCK	1	;YEAR
0064+  3F21             ;
0065+  3F21             BAUD	.BLOCK	2	;BIT BANG BAUD RATE
0066+  3F23             KEYTIM	.BLOCK	2	;BEEP DELAY
0067+  3F25             SPTEMP	.BLOCK	2	;TEMP SYSTEM CALL SP
0068+  3F27             ;
0069+  3F27             ; BLOCK FUNCTIONS
0070+  3F27             ;
0071+  3F27             COUNT	.BLOCK	2	;NUMBER OF BYTES TO MOVE
0072+  3F29             BLKSRT	.BLOCK	2	;BLOCK START ADDRESS
0073+  3F2B             BLKEND	.BLOCK	2	;BLOCK END ADDRESS
0074+  3F2D             BLKDST	.BLOCK	2	;DESTINATION ADDRESS
0075+  3F2F             ;
0076+  3F2F             FUNJMP	.BLOCK	2	;FN FN KEY JUMP ADDRESS
0077+  3F31             ;
0078+  3F31             ; DISPLAY SCAN REGISTERS
0079+  3F31             ;
0080+  3F31             DISBUF	.BLOCK	6	;DISPLAY BUFFER
0081+  3F37             ONTIM	.BLOCK	1	;DISPLAY SCAN ON TIME
0082+  3F38             OFTIM	.BLOCK	1	;DISPLAY SCAN OFF TIME
0083+  3F39             ;
0084+  3F39             ; MONITOR VARIABLES
0085+  3F39             ;
0086+  3F39             MODE	.BLOCK	2	;DISPLAY MODE
0087+  3F3B             ADRESS	.BLOCK	2	;USER ADDRESS
0088+  3F3D             KEYDEL	.BLOCK	2	;AUTO INCREMENT DELAY
0089+  3F3F             ;
0090+  3F3F             ; TEMPORARY REGISTER STORAGE
0091+  3F3F             ;
0092+  3F3F             REGPNT	.BLOCK	2	;REGISTER POINTER
0093+  3F41             TMPPC	.BLOCK	2	;PROGRAM COUNTER
0094+  3F43             TMPAF	.BLOCK	2	;ACCUMULATOR,FLAG
0095+  3F45             TMPBC	.BLOCK	2	;BC REGISTER PAIR
0096+  3F47             TMPDE	.BLOCK	2	;DE REGISTER PAIR
0097+  3F49             TMPHL	.BLOCK	2	;HL REGISTER PAIR
0098+  3F4B             TMPIX	.BLOCK	2	;INDEX REGISTER X
0099+  3F4D             TMPIY	.BLOCK	2	;INDEX REGISTER Y
0100+  3F4F             TMPSP	.BLOCK	2	;STACK POINTER
0101+  3F51             ;
0102+  3F51             ; RESTART JUMP TABLE AND HARWARE TEST
0103+  3F51             ;
0104+  3F51             RST08	.BLOCK	2	;RESTART 08H JUMP
0105+  3F53             RST10	.BLOCK	2	;RESTART 10H JUMP
0106+  3F55             RST18	.BLOCK	2	;RESTART 18H JUMP
0107+  3F57             RST20	.BLOCK	2	;RESTART 20H JUMP
0108+  3F59             RST28	.BLOCK	2	;RESTART 28H JUMP
0109+  3F5B             RST38	.BLOCK	2	;INT INTERRUPT JUMP
0110+  3F5D             RST66	.BLOCK	2	;NMI INTERRUPT JUMP
0111+  3F5F             RAMSUM	.BLOCK	1	;USER RAM CHECKSUM
0112+  3F60             DALLAS	.BLOCK	1	;RAM TEST LOCATION
0113+  3F61             SYSERR	.BLOCK	2	;SYSTEM CALL ERROR JUMP
0114+  3F63             ;--------------------
0115+  3F63             ; SYSTEM CALL NUMBERS
0116+  3F63             ;--------------------
0117+  3F63             ;
0118+  3F63             ;  LD   C,SYSTEM CALL NUMBER
0119+  3F63             ;  RST  30H
0120+  3F63             ;
0121+  3F63             MAIN	.EQU	0	;RESTART MONITOR
0122+  3F63             VERS	.EQU	1	;RETURNS MONITOR VERSION
0123+  3F63             DISADD	.EQU	2	;ADDRESS -> DISPLAY BUFFER
0124+  3F63             DISBYT	.EQU	3	;DATA -> DISPLAY BUFFER
0125+  3F63             CLRBUF	.EQU	4	;CLEAR DISPLAY BUFFER
0126+  3F63             SCAND	.EQU	5	;SCAN DISPLAY
0127+  3F63             CONBYT	.EQU	6	;BYTE -> DISPLAY CODE
0128+  3F63             CONVHI	.EQU	7	;HI NYBBLE -> DISPLAY CODE
0129+  3F63             CONVLO	.EQU	8	;LO NYBBLE - > DISPLAY CODE
0130+  3F63             SKEYIN	.EQU	9	;SCAN DISPLAY UNTIL KEY PRESS
0131+  3F63             SKEYRL	.EQU	10	;SCAN DISPLAY UNTIL KEY RELEASE
0132+  3F63             KEYIN	.EQU	11	;WAIT FOR KEY PRESS
0133+  3F63             KEYREL	.EQU	12	;WAIT FOR KEY RELEASE
0134+  3F63             MENU	.EQU	13	;SELECT ENTRY FROM MENU
0135+  3F63             CHKSUM	.EQU	14	;CALCULATE CHECKSUM
0136+  3F63             MUL16	.EQU	15	;16 BIT MULTIPLY
0137+  3F63             RAND	.EQU	16	;GENERATE RANDOM NUMBER
0138+  3F63             INDEXB	.EQU	17	;INDEX INTO BYTE TABLE
0139+  3F63             INDEXW	.EQU	18	;INDEX INTO WORD TABLE
0140+  3F63             MUSIC	.EQU	19	;PLAY MUSIC TABLE
0141+  3F63             TONE	.EQU	20	;PLAY A NOTE
0142+  3F63             BEEP	.EQU	21	;KEY ENTRY BEEP
0143+  3F63             SKATE	.EQU	22	;SCAN 8X8 DISPLAY
0144+  3F63             TXDATA	.EQU	23	;TRANSMIT SERIAL BYTE
0145+  3F63             RXDATA	.EQU	24	;RECEIVE SERIAL BYTE
0146+  3F63             ASCHEX	.EQU	25	;ASCII CODE -> HEX
0147+  3F63             WWATCH	.EQU	26	;WRITE TO SMART WATCH
0148+  3F63             RWATCH	.EQU	27	;READ FROM SMART WATCH
0149+  3F63             ONESEC	.EQU	28	;ONE SECOND DELAY USING SMARTWATCH
0150+  3F63             RLSTEP	.EQU	29	;RELAY S.EQUENCER
0151+  3F63             DELONE	.EQU	30	;ONE SECOND DELAY LOOP
0152+  3F63             SCANKEY .EQU	31	;SCAN THE KEYBOARD
0153+  3F63             INTELH	.EQU	32	;RECEIVE INTEL HEX FILE
0154+  3F63             SPLIT	.EQU	33	;SEPARATE A BYTE INTO NYBBLES
0155+  3F63             SNDMSG	.EQU	34	;SND ZERO TERMINATED STRING TO SERIAL PORT
0156+  3F63             BITASC	.EQU	35	;CONVERT A BYTE INTO AN ASCII STRING OF ONES AND ZEROES
0157+  3F63             WRDASC	.EQU	36	;CONVERT A WORD TO ASCII
0158+  3F63             BYTASC	.EQU	37	;CONVERT A BYTE TO ASCII
0159+  3F63             NYBASC	.EQU	38	;CONVERT A NYBBLE TO ASCII
0160+  3F63             PCBTYP	.EQU	39	;RETURNS BOARD TYPE, SC OR TEC-1F
0161+  3F63             PRNTSZ	.EQU	40	;INLINE SERIAL PRINT STRING
0162+  3F63             KBDTYP	.EQU	41	;RETURNS KEYBOARD TYPE
0163+  3F63             UPDATE	.EQU	42  ;UPDATE DISPLAY AND MODE DECIMAL POINT SEGMENTS
0164+  3F63             VARRAM	.EQU	43	;RETURN BASE VARIABLE ADDRESS
0165+  3F63             SERINI	.EQU	44	;INITIALISE BIT BANG SERIAL PORT
0166+  3F63             SCBUG	.EQU	45	;SCBUG SERIAL MONITOR
0167+  3F63             
0168+  3F63             ;END OF INCLUDE FILE
0009   3F63             
0010   3F63             
0011   2000             	.org	2000h
0012   2000             
0013   2000 0E 2C       	ld c,SERINI
0014   2002 F7          	rst 30h
0015   2003             
0016   2003 CD 7C 21    	call i2c_init			; setup port
0017   2006             
0018   2006 3E 01       	ld a,1				; set basic state
0019   2008 32 76 21    	ld (shifted),a
0020   200B 32 77 21    	ld (caps),a
0021   200E             
0022   200E             
0023   200E 16 ED       krst:	ld d,0edh			; set leds state
0024   2010 CD 10 22    	call i2c_ATtx
0025   2013 16 00       	ld d,0				; kb leds bits all off
0026   2015 CD 10 22    	call i2c_ATtx
0027   2018             
0028   2018             
0029   2018             
0030   2018             ;debug:	call keydump
0031   2018             ;	jr debug
0032   2018             
0033   2018             
0034   2018 CD 3B 20    mloop:	call getkey
0035   201B FE 00       	cp 00h
0036   201D 28 F9       	jr z,mloop
0037   201F             
0038   201F             
0039   201F CD 92 20    	call scan2asc
0040   2022 FE FF       	cp 0ffh
0041   2024 28 F2       	jr z,mloop
0042   2026             
0043   2026 0E 17       	ld c,TXDATA
0044   2028 F7          	rst 30h
0045   2029             
0046   2029 18 ED       	jr mloop
0047   202B             
0048   202B             
0049   202B             
0050   202B             ; ------------------------------------------------------
0051   202B             ; keydump - waits for a keypress
0052   202B             ;
0053   202B             ; prints scan code to serial terminal
0054   202B             ; ------------------------------------------------------
0055   202B             
0056   202B             keydump:
0057   202B             
0058   202B CD E7 21    	call i2c_ATrx
0059   202E             
0060   202E 21 78 21    	ld hl,buff
0061   2031 0E 25       	ld c,BYTASC
0062   2033 F7          	rst 30h
0063   2034             
0064   2034 21 78 21    	ld hl,buff
0065   2037 0E 22       	ld c,SNDMSG
0066   2039 F7          	rst 30h
0067   203A             
0068   203A C9          	ret
0069   203B             
0070   203B             
0071   203B             
0072   203B             
0073   203B             
0074   203B             ; ------------------------------------------------------
0075   203B             ; getkey - waits for a keypress
0076   203B             ;
0077   203B             ; returns with scancode in A or 00 = no valid key
0078   203B             ;
0079   203B             ; carry set if special key, otherwise cleared
0080   203B             ; ------------------------------------------------------
0081   203B             
0082   203B             getkey:
0083   203B CD E7 21     	call i2c_ATrx		; wait for a keystroke
0084   203E             
0085   203E FE F0       	cp 0f0h			; release?
0086   2040 28 12       	jr z, release
0087   2042             
0088   2042 FE E0       	cp 0e0h
0089   2044 28 1B       	jr z, special		; special key?
0090   2046             
0091   2046 FE 12       	cp 12h			; shift?
0092   2048 28 20       	jr z,shifton
0093   204A FE 59       	cp 59h
0094   204C 28 1C       	jr z,shifton
0095   204E             
0096   204E FE 58       	cp 58h			; caps lock?
0097   2050 28 26       	jr z,capstog
0098   2052             
0099   2052 B7          	or a			; clear carry
0100   2053 C9          	ret			; return normal scan code
0101   2054             
0102   2054             
0103   2054             ; f0h, xxh
0104   2054             release:
0105   2054 CD E7 21    	call i2c_ATrx		; get but ignore (most) keys
0106   2057             
0107   2057 FE 12       	cp 12h
0108   2059 28 16       	jr z,shiftoff
0109   205B FE 59       	cp 59h
0110   205D 28 12       	jr z,shiftoff
0111   205F             
0112   205F AF          	xor a
0113   2060 C9          	ret
0114   2061             
0115   2061             
0116   2061             ; e0h xxxh
0117   2061             special:
0118   2061 CD E7 21    	call i2c_ATrx
0119   2064 FE F0       	cp 0f0h
0120   2066 28 EC       	jr z, release
0121   2068             
0122   2068             ;	xor a			; we ignoring special keys for now
0123   2068 37          	scf			; set carry
0124   2069 C9          	ret
0125   206A             
0126   206A             shifton:
0127   206A 3E 02       	ld a,2
0128   206C 32 76 21    	ld (shifted),a
0129   206F AF          	xor a
0130   2070 C9          	ret
0131   2071             
0132   2071             shiftoff:
0133   2071 3E 01       	ld a,1
0134   2073 32 76 21    	ld (shifted),a
0135   2076 AF          	xor a
0136   2077 C9          	ret
0137   2078             
0138   2078             capstog:
0139   2078 3A 77 21    	ld a,(caps)			; flip status bit
0140   207B EE 03       	xor 3
0141   207D 32 77 21    	ld (caps),a
0142   2080             
0143   2080 16 ED       	ld d,0edh			; set leds state
0144   2082 CD 10 22    	call i2c_ATtx
0145   2085             
0146   2085 3A 77 21    	ld a,(caps)
0147   2088 CB 27       	sla a
0148   208A E6 04       	and 04h
0149   208C 57          	ld d,a				; kb leds bits
0150   208D CD 10 22    	call i2c_ATtx
0151   2090             
0152   2090 AF          	xor a
0153   2091 C9          	ret
0154   2092             
0155   2092             
0156   2092             
0157   2092             ; ------------------------------------------------------
0158   2092             ; scan code to ASCII conversion
0159   2092             ;
0160   2092             ;
0161   2092             ; in: A = scancode
0162   2092             ; out A = translated ASCII value or FFh if not translatable
0163   2092             ; ------------------------------------------------------
0164   2092             
0165   2092             
0166   2092 5F          scan2asc:	ld e,a
0167   2093 30 06       		jr nc,norkey
0168   2095             
0169   2095             ;special keys
0170   2095 21 71 21    		ld hl,specialtable
0171   2098 5F          		ld e,a
0172   2099 18 0D       		jr ascloop
0173   209B             
0174   209B 21 C8 20    norkey:		ld hl,keytable
0175   209E             
0176   209E 3A 76 21    		ld a,(shifted)
0177   20A1 FE 01       		cp 1
0178   20A3 28 03       		jr z,ascloop
0179   20A5             
0180   20A5 21 36 21    		ld hl,shtable
0181   20A8             
0182   20A8             
0183   20A8 7E          ascloop:	ld a,(hl)
0184   20A9 23          		inc hl
0185   20AA FE FF       		cp 0ffh			; end of table?
0186   20AC C8          		ret z
0187   20AD             
0188   20AD BB          		cp e
0189   20AE 28 03       		jr z, fixx
0190   20B0             
0191   20B0 23          		inc hl
0192   20B1 18 F5       		jr ascloop		; try next map
0193   20B3             
0194   20B3 7E          fixx:		ld a,(hl)
0195   20B4             
0196   20B4 FE 7B       		cp 07bh			; ignore { | } ~ and DEL
0197   20B6 D0          		ret nc
0198   20B7             
0199   20B7             ; now fix case
0200   20B7 FE 61       		cp 61h			; letters?
0201   20B9 D8          		ret c
0202   20BA             
0203   20BA 5F          		ld e,a
0204   20BB             
0205   20BB             ; use xor logic!!
0206   20BB             
0207   20BB 3A 76 21    		ld a,(shifted)
0208   20BE 47          		ld b,a
0209   20BF 3A 77 21    		ld a,(caps)
0210   20C2 A8          		xor b
0211   20C3 7B          		ld a,e
0212   20C4 C8          		ret z
0213   20C5             
0214   20C5             
0215   20C5 D6 20       toupper:	sub 020h
0216   20C7 C9          		ret
0217   20C8             
0218   20C8             
0219   20C8             
0220   20C8             ; for letters, or when shift is not pressed
0221   20C8             
0222   20C8 1C 61       keytable:	.db 01ch,'a'
0223   20CA 32 62       		.db 032h,'b'
0224   20CC 21 63       		.db 021h,'c'
0225   20CE 23 64       		.db 023h,'d'
0226   20D0 24 65       		.db 024h,'e'
0227   20D2 2B 66       		.db 02bh,'f'
0228   20D4 34 67       		.db 034h,'g'
0229   20D6 33 68       		.db 033h,'h'
0230   20D8 43 69       		.db 043h,'i'
0231   20DA 3B 6A       		.db 03bh,'j'
0232   20DC 42 6B       		.db 042h,'k'
0233   20DE 4B 6C       		.db 04bh,'l'
0234   20E0 3A 6D       		.db 03ah,'m'
0235   20E2 31 6E       		.db 031h,'n'
0236   20E4 44 6F       		.db 044h,'o'
0237   20E6 4D 70       		.db 04dh,'p'
0238   20E8 15 71       		.db 015h,'q'
0239   20EA 2D 72       		.db 02dh,'r'
0240   20EC 1B 73       		.db 01bh,'s'
0241   20EE 2C 74       		.db 02ch,'t'
0242   20F0 3C 75       		.db 03ch,'u'
0243   20F2 2A 76       		.db 02ah,'v'
0244   20F4 1D 77       		.db 01dh,'w'
0245   20F6 22 78       		.db 022h,'x'
0246   20F8 35 79       		.db 035h,'y'
0247   20FA 1A 7A       		.db 01ah,'z'
0248   20FC             
0249   20FC 45 30       		.db 045h,'0'
0250   20FE 16 31       		.db 016h,'1'
0251   2100 1E 32       		.db 01eh,'2'
0252   2102 26 33       		.db 026h,'3'
0253   2104 25 34       		.db 025h,'4'
0254   2106 2E 35       		.db 02eh,'5'
0255   2108 36 36       		.db 036h,'6'
0256   210A 3D 37       		.db 03dh,'7'
0257   210C 3E 38       		.db 03eh,'8'
0258   210E 46 39       		.db 046h,'9'
0259   2110             
0260   2110 0E 60       		.db 00eh,'`'
0261   2112 4E 2D       		.db 04eh,'-'
0262   2114 55 3D       		.db 055h,'='
0263   2116 5D 5C       		.db 05dh,'\'
0264   2118 54 5B       		.db 054h,'['
0265   211A 5B 5D       		.db 05bh,']'
0266   211C 4C 3B       		.db 04ch,';'
0267   211E 41 2C       		.db 041h,','
0268   2120 49 2E       		.db 049h,'.'
0269   2122 4A 2F       		.db 04ah,'/'
0270   2124             
0271   2124             ; keypad keys
0272   2124 7C 2A       		.db 07ch,'*'
0273   2126 7B 2D       		.db 07bh,'-'
0274   2128 79 2B       		.db 079h,'+'
0275   212A             
0276   212A             ; nonprinting keys
0277   212A 29 20       		.db 029h,' '	; Space
0278   212C 5A 0D       		.db 05ah,0dh	; Enter
0279   212E 66 7F       		.db 066h,7fh	; bkspc
0280   2130 0D 09       		.db 00dh,09h	; Tab
0281   2132 76 1B       		.db 076h,1bh	; Esc
0282   2134 52 27       		.db 052h,27h	; Apostrophe
0283   2136             
0284   2136             
0285   2136             
0286   2136             ; for when shift is pressed
0287   2136             
0288   2136 45 29       shtable:	.db 045h,')'
0289   2138 16 21       		.db 016h,'!'
0290   213A 1E 40       		.db 01eh,'@'
0291   213C 26 23       		.db 026h,'#'
0292   213E 25 24       		.db 025h,'$'
0293   2140 2E 25       		.db 02eh,'%'
0294   2142 36 5E       		.db 036h,'^'
0295   2144 3D 26       		.db 03dh,'&'
0296   2146 3E 2A       		.db 03eh,'*'
0297   2148 46 28       		.db 046h,'('
0298   214A             
0299   214A 0E 7E       		.db 00eh,'~'
0300   214C 4E 5F       		.db 04eh,'_'
0301   214E 55 2B       		.db 055h,'+'
0302   2150 5D 7C       		.db 05dh,'|'
0303   2152 54 7B       		.db 054h,'{'
0304   2154 5B 7D       		.db 05bh,'}'
0305   2156 4C 3A       		.db 04ch,':'
0306   2158 41 3C       		.db 041h,'<'
0307   215A 49 3E       		.db 049h,'>'
0308   215C 4A 3F       		.db 04ah,'?'
0309   215E 52 22       		.db 052h,22h	; Quotation mark
0310   2160             
0311   2160             
0312   2160             ; keypad keys
0313   2160 7C 2A       		.db 07ch,'*'
0314   2162 7B 2D       		.db 07bh,'-'
0315   2164 79 2B       		.db 079h,'+'
0316   2166             
0317   2166             ; nonprinting keys
0318   2166 29 20       		.db 029h,' '	; Space
0319   2168 5A 0D       		.db 05ah,0dh	; Enter
0320   216A 66 7F       		.db 066h,7fh	; bkspc
0321   216C 0D 09       		.db 00dh,09h	; Tab
0322   216E 76 1B       		.db 076h,1bh	; Esc
0323   2170             
0324   2170 FF          		.db 0ffh	; end of table
0325   2171             
0326   2171             ; E0 xx codes
0327   2171 4A 2F       specialtable:	.db 04ah,'/'	; numeric slash
0328   2173 5A 0D       		.db 05ah,0dh	; numeric Enter
0329   2175 FF          		.db 0ffh
0330   2176             
0331   2176 01          shifted:	.db 01h
0332   2177 01          caps:		.db 01h
0333   2178             
0334   2178 30 30 20 00 buff		.db "00 ",0
0335   217C             
0336   217C             #include "C:/Users/User/OneDrive/TEC-1/SC-1/IOboard/spi2c_library.asm"
0001+  217C             ; ----------------------------------------------------------------------------
0002+  217C             ; 	Libraries for SPI2C board.
0003+  217C             ;
0004+  217C             ;	Copyright (C) 2023, Craig Hart. Distributed under the GPLv3 license.
0005+  217C             ;
0006+  217C             ;	https://github.com/1971Merlin/SPI2C
0007+  217C             ;
0008+  217C             ; ----------------------------------------------------------------------------
0009+  217C             
0010+  217C             ; ----------------------------------------------------------------------------
0011+  217C             ;
0012+  217C             ; Common Parameters
0013+  217C             ;
0014+  217C             ; the user should change the ports according to the hardware in use
0015+  217C             ;
0016+  217C             ; ----------------------------------------------------------------------------
0017+  217C             
0018+  217C             
0019+  217C             i2cport	.equ 40h	; IO port our I2C "controller" lives on
0020+  217C             			; 40h for SC-1 using the onboard 74HC138
0021+  217C             			; user selected for TEC-1
0022+  217C             
0023+  217C             spiport	.equ 42h	; IO port our SPI "controller" lives on
0024+  217C             			; 42h for SC-1 using the onboard 74HC138
0025+  217C             			; user selected for TEC-1
0026+  217C             
0027+  217C             	
0028+  217C             spics1	.equ 0fbh
0029+  217C             spics2	.equ 0efh
0030+  217C             spics3	.equ 0dfh
0031+  217C             spics4	.equ 0bfh
0032+  217C             spics5	.equ 07fh
0033+  217C             
0034+  217C             
0035+  217C             
0036+  217C             ; ----------------------------------------------------------------------------
0037+  217C             ; I2C Routines
0038+  217C             ; ----------------------------------------------------------------------------
0039+  217C             
0040+  217C             i2cidle	.equ 03h
0041+  217C             
0042+  217C             i2c_init:
0043+  217C F5          	push af
0044+  217D 3E 03       	ld a,i2cidle	; idle state = SCL and SDA both high
0045+  217F D3 40       	out (i2cport),a
0046+  2181 F1          	pop af
0047+  2182 C9          	ret
0048+  2183             
0049+  2183             ; ----------------------------------------------------------------------------
0050+  2183             ; Routine to make the i2c bus active
0051+  2183             ; ----------------------------------------------------------------------------
0052+  2183             
0053+  2183             i2c_start:
0054+  2183 F5          	push af
0055+  2184 3E 02       	ld a,02h	; SCL 1, SDA 0 = start
0056+  2186 D3 40       	out (i2cport),a
0057+  2188 3E 00       	ld a,00h
0058+  218A D3 40       	out (i2cport),a	; SCL 0, SDA 0 = bus idle active
0059+  218C F1          	pop af
0060+  218D C9          	ret
0061+  218E             
0062+  218E             ; ----------------------------------------------------------------------------
0063+  218E             ; Routine to return i2c bus to idle
0064+  218E             ; ----------------------------------------------------------------------------
0065+  218E             
0066+  218E             i2c_stop:
0067+  218E F5          	push af
0068+  218F 3E 01       	ld a,01h	; SCL 0, SDA 1 = stop
0069+  2191 D3 40       	out (i2cport),a
0070+  2193 3E 03       	ld a,03h
0071+  2195 D3 40       	out (i2cport),a	; SCL 1, SDA 1 = bus idle inactive
0072+  2197 F1          	pop af
0073+  2198 C9          	ret
0074+  2199             
0075+  2199             ; ----------------------------------------------------------------------------
0076+  2199             ; Routine to transmit a byte on the i2c bus
0077+  2199             ;
0078+  2199             ; enter  d = byte to send
0079+  2199             ; return d bit 0 = result; 0 = accepted/OK; 1 = ignored/no device
0080+  2199             ; ----------------------------------------------------------------------------
0081+  2199             
0082+  2199             i2c_txbyte:
0083+  2199 F5          	push af
0084+  219A C5          	push bc
0085+  219B             
0086+  219B 06 08       	ld b,8		; 8 bits
0087+  219D             
0088+  219D             txbyte1:
0089+  219D 3E 00       	ld a,00h	; prep CL=low, data = ?
0090+  219F CB 02       	rlc d		; set CF = data
0091+  21A1 8F          	adc a,a		; set bit 0 to our data
0092+  21A2 D3 40       	out (i2cport),a	; SDA=data, SCL = 0
0093+  21A4             
0094+  21A4 CB CF       	set 1,a		; Pulse SCL high
0095+  21A6 D3 40       	out (i2cport),a
0096+  21A8 CB 8F       	res 1,a		; and SCL low again
0097+  21AA D3 40       	out (i2cport),a
0098+  21AC             
0099+  21AC 05          	dec b
0100+  21AD 20 EE       	jr nz, txbyte1
0101+  21AF             
0102+  21AF             ; get ACK since we did a set address command --
0103+  21AF             ; if the device is there we should get an answer bit = 0
0104+  21AF             
0105+  21AF 3E 03       rxack:	ld a,03h	; SET SCL = 1 (leave data high = bus free for response)
0106+  21B1 D3 40       	out (i2cport),a
0107+  21B3 DB 40       	in a,(i2cport)	;get result; 0 = response received
0108+  21B5 57          	ld d,a		; store d=result
0109+  21B6 3E 01       	ld a,01h	; SCL = 0, SDA = 1
0110+  21B8 D3 40       	out (i2cport),a
0111+  21BA             
0112+  21BA             ; d holds our result, bit zro should be a 0 if an ACK received
0113+  21BA             
0114+  21BA C1          	pop bc
0115+  21BB F1          	pop af
0116+  21BC C9          	ret
0117+  21BD             
0118+  21BD             ; ----------------------------------------------------------------------------
0119+  21BD             ; Routine to receive a byte from the i2c bus
0120+  21BD             ;
0121+  21BD             ; return d = result
0122+  21BD             ; ----------------------------------------------------------------------------
0123+  21BD             
0124+  21BD             i2c_rxbyte:
0125+  21BD F5          	push af
0126+  21BE C5          	push bc
0127+  21BF             
0128+  21BF 06 08       	ld b,8		; 8 bits
0129+  21C1 16 00       	ld d,00h	; (our data to be read)
0130+  21C3             
0131+  21C3             rxbyte1:
0132+  21C3 3E 01       	ld a,01h	; prep SCL=low, data = high (tristate output)
0133+  21C5 D3 40       	out (i2cport),a	; SDA=data, SCL = 0
0134+  21C7             
0135+  21C7 3E 03       	ld a,03h	; SCL = 1, SDA = 1
0136+  21C9 D3 40       	out (i2cport),a
0137+  21CB             
0138+  21CB DB 40       	in a,(i2cport)	; read bit (they send us SDA)
0139+  21CD CB 0F       	rrc a		; store into CF
0140+  21CF CB 12       	rl d		; and read into d
0141+  21D1             
0142+  21D1 3E 01       	ld a,01h
0143+  21D3 D3 40       	out (i2cport),a	; SCL = 0, SDA = 1 (tristate output)
0144+  21D5             
0145+  21D5 05          	dec b
0146+  21D6 20 EB       	jr nz, rxbyte1
0147+  21D8             
0148+  21D8             ; send ACK since we read a byte
0149+  21D8             
0150+  21D8 3E 01       txack:	ld a,01h	; Setup ACK pulse SCL=0 with SDA=1
0151+  21DA D3 40       	out (i2cport),a
0152+  21DC 3E 03       	ld a,03h	; Send ACK SCL = 1, SDA = 1
0153+  21DE D3 40       	out (i2cport),a
0154+  21E0 3E 01       	ld a,01h	; lower SCL; idle ready state
0155+  21E2 D3 40       	out (i2cport),a
0156+  21E4             
0157+  21E4 C1          	pop bc
0158+  21E5 F1          	pop af
0159+  21E6 C9          	ret
0160+  21E7             
0161+  21E7             
0162+  21E7             ; ----------------------------------------------------------------------------
0163+  21E7             ; Routine to receive an AT keyboard byte from the i2c bus
0164+  21E7             ;
0165+  21E7             ; return a = result
0166+  21E7             ; ----------------------------------------------------------------------------
0167+  21E7             
0168+  21E7             i2c_ATrx:
0169+  21E7             
0170+  21E7 CD FC 21    	call rxAT	; get the start bit and discard it
0171+  21EA             
0172+  21EA 06 08       	ld b,8		; 8 bits
0173+  21EC 16 00       	ld d,00h	; (our data to be read)
0174+  21EE             
0175+  21EE CD FC 21    ATbits:	call rxAT	; get 8 data bits
0176+  21F1 10 FB       	djnz ATbits
0177+  21F3             
0178+  21F3 4A          	ld c,d		; backup for later
0179+  21F4             
0180+  21F4 CD FC 21    	call rxAT	; get parity bit and discard it
0181+  21F7 CD FC 21    	call rxAT	; get stop bit and discard it
0182+  21FA             
0183+  21FA 79          	ld a,c		; restore value
0184+  21FB             
0185+  21FB C9          	ret
0186+  21FC             
0187+  21FC             
0188+  21FC             
0189+  21FC             
0190+  21FC             rxAT:
0191+  21FC             
0192+  21FC DB 42       rxAT1:	in a,(spiport)	; read
0193+  21FE E6 08       	and 08h
0194+  2200 C2 FC 21    	jp nz,rxAT1	; wait for clk to go low
0195+  2203             
0196+  2203 DB 40       	in a,(i2cport)	; read bit 0 == data
0197+  2205 0F          	rrca		; bit 0 into carry
0198+  2206 CB 1A       	rr d		; carry into d bit 7, shifting right each time
0199+  2208             
0200+  2208 DB 42       rxAT2:	in a,(spiport)	; wait for clock to go high
0201+  220A E6 08       	and 08h
0202+  220C CA 08 22    	jp z,rxAT2
0203+  220F             
0204+  220F C9          	ret
0205+  2210             
0206+  2210             
0207+  2210             
0208+  2210             
0209+  2210             
0210+  2210             ; ----------------------------------------------------------------------------
0211+  2210             ; Routine to transmit an AT keyboard byte from the i2c bus
0212+  2210             ;
0213+  2210             ; d = byte to transmit
0214+  2210             ; ----------------------------------------------------------------------------
0215+  2210             
0216+  2210             i2c_ATtx:
0217+  2210             
0218+  2210 0E 00       	ld c,0
0219+  2212             
0220+  2212 7A          	ld a,d
0221+  2213 B7          	or a			; set parity bit
0222+  2214 E2 19 22    	jp po,noparity
0223+  2217             
0224+  2217 0E 01       	ld c,1
0225+  2219             
0226+  2219             noparity:
0227+  2219 3E 01       	ld a,01
0228+  221B D3 40       	out (i2cport),a		; CLK low (bit 1) data high (bit 0)
0229+  221D             
0230+  221D 06 09       	ld b,09h			; delay 100us
0231+  221F 10 FE       grabck:	djnz grabck
0232+  2221             
0233+  2221 3E 00       	ld a,00			; both low
0234+  2223 D3 40       	out (i2cport),a
0235+  2225             	
0236+  2225 00          	nop
0237+  2226 00          	nop
0238+  2227 00          	nop
0239+  2228 00          	nop
0240+  2229             
0241+  2229 3E 02       	ld a,02		; CLK high data low; start bit
0242+  222B D3 40       	out (i2cport),a
0243+  222D             
0244+  222D CD 4D 22    	call txAT1	; wait ack.
0245+  2230             
0246+  2230             
0247+  2230 06 08       	ld b,8		; now send 8 data bits
0248+  2232             	
0249+  2232 CD 48 22    ATbit2:	call txAT
0250+  2235 CB 3A       	srl d
0251+  2237 10 F9       	djnz ATbit2
0252+  2239             
0253+  2239 51          	ld d,c		; send parity  bit
0254+  223A CD 48 22    	call txAT
0255+  223D             
0256+  223D 3E 03       	ld a,03		; back to idle
0257+  223F D3 40       	out (i2cport),a
0258+  2241             
0259+  2241             
0260+  2241 CD FC 21    	call rxAT
0261+  2244 CD FC 21    	call rxAT
0262+  2247             
0263+  2247             ;	ld b,0fh	; small delay
0264+  2247             ;ignore:	djnz ignore
0265+  2247             	
0266+  2247             	
0267+  2247 C9          	ret
0268+  2248             
0269+  2248             
0270+  2248 7A          txAT:	ld a,d
0271+  2249 F6 02       	or 2		; keep CLK high our side, set data bit =b0
0272+  224B D3 40       	out (i2cport),a	; set bit 0 == data
0273+  224D             
0274+  224D DB 42       txAT1:	in a,(spiport)
0275+  224F E6 08       	and 08h
0276+  2251 CA 4D 22    	jp z,txAT1	; wait for clk to go high
0277+  2254             
0278+  2254             
0279+  2254             	
0280+  2254 DB 42       txAT2:	in a,(spiport)	; wait for clock to go low
0281+  2256 E6 08       	and 08h
0282+  2258 C2 54 22    	jp nz,txAT2
0283+  225B             
0284+  225B C9          	ret
0285+  225C             	
0286+  225C             
0287+  225C             
0288+  225C             
0289+  225C             ; ----------------------------------------------------------------------------
0290+  225C             ; SPI Routines
0291+  225C             ; ----------------------------------------------------------------------------
0292+  225C             
0293+  225C             spiidle	.equ 0f4h	; Idle state
0294+  225C             
0295+  225C             ; SPI port bits
0296+  225C             ;
0297+  225C             ; bit 0 - MOSI/MISO
0298+  225C             ; bit 1 - CLK
0299+  225C             ; bit 2 - CS1
0300+  225C             ; bit 3 - D/C
0301+  225C             ; bit 4 - CS2
0302+  225C             ; bit 5 - CS3
0303+  225C             ; bit 6 - CS4
0304+  225C             ; bit 7 - CS5
0305+  225C             
0306+  225C             ; ----------------------------------------------------------------------------
0307+  225C             ; SPI initialization code starts here; call once at start of code
0308+  225C             ;
0309+  225C             ; idle state == 1111 0100  === MOSI, D/C and CLK low, CSx all high
0310+  225C             ; ----------------------------------------------------------------------------
0311+  225C             
0312+  225C             spi_init:
0313+  225C F5          	push af
0314+  225D 3E F4       	ld a,spiidle	; Set idle state
0315+  225F D3 42       	out (spiport),a
0316+  2261 F1          	pop af
0317+  2262 C9          	ret
0318+  2263             
0319+  2263             ; ----------------------------------------------------------------------------
0320+  2263             ; Routine to send byte to the SPI bus
0321+  2263             ;
0322+  2263             ; c = SPI CS pin required (use the spics EQUs above)
0323+  2263             ; d = command/data 00 = command, 08 = data
0324+  2263             ; e = data byte
0325+  2263             ;
0326+  2263             ; no results returned, no registers odified
0327+  2263             ; ----------------------------------------------------------------------------
0328+  2263             
0329+  2263 F5          spi_wr:	push af
0330+  2264 D5          	push de
0331+  2265 CD 80 22    	call spi_wrb
0332+  2268 18 0F       	jr spi_done
0333+  226A             
0334+  226A             ; ----------------------------------------------------------------------------
0335+  226A             ; Routine to send two bytes to the SPI bus
0336+  226A             ;
0337+  226A             ; c = SPI CS pin required (use the spics EQUs above)
0338+  226A             ; d = command byte
0339+  226A             ; e = data byte
0340+  226A             ;
0341+  226A             ; no results returned, no registers modified
0342+  226A             ; ----------------------------------------------------------------------------
0343+  226A             
0344+  226A             spi_wrw:
0345+  226A F5          	push af
0346+  226B D5          	push de
0347+  226C 7B          	ld a,e
0348+  226D 5A          	ld e,d
0349+  226E 16 08       	ld d,08h
0350+  2270 CD 80 22    	call spi_wrb
0351+  2273             
0352+  2273 5F          	ld e,a
0353+  2274 16 08       	ld d,08h
0354+  2276 CD 80 22    	call spi_wrb
0355+  2279             
0356+  2279             spi_done:	
0357+  2279 3E F4       	ld a,spiidle	; return to idle mode
0358+  227B D3 42       	out (spiport),a
0359+  227D D1          	pop de
0360+  227E F1          	pop af
0361+  227F C9          	ret
0362+  2280             
0363+  2280             ; ----------------------------------------------------------------------------
0364+  2280             ; Routine to transmit one byte to the SPI bus
0365+  2280             ;
0366+  2280             ; c = SPI CS pin required (use the spics EQUs above)
0367+  2280             ; d = command/data 00 = command, 08 = data
0368+  2280             ; e = data byte
0369+  2280             ;
0370+  2280             ; no results returned, no registers modified
0371+  2280             ; ----------------------------------------------------------------------------
0372+  2280             
0373+  2280             spi_wrb:
0374+  2280 F5          	push af
0375+  2281 C5          	push bc
0376+  2282 D5          	push de
0377+  2283             
0378+  2283 06 08       	ld b,8		; 8 BITS
0379+  2285             
0380+  2285 3E F4       nbit:	ld a,spiidle	; starting point
0381+  2287 B2          	or d		; add in the command/data register select
0382+  2288 A1          	and c		; add in the CS pin
0383+  2289 CB 7B       	bit 7,e
0384+  228B 28 02       	jr z, no
0385+  228D CB C7       	set 0,a
0386+  228F             
0387+  228F D3 42       no:	out (spiport),a
0388+  2291 CB CF       	set 1,a		; set CLK
0389+  2293 D3 42       	out (spiport),a
0390+  2295 CB 8F       	res 1,a		; clear CLK
0391+  2297 D3 42       	out (spiport),a
0392+  2299 CB 03       	rlc e		; next bit
0393+  229B 10 E8       	djnz nbit
0394+  229D             
0395+  229D D1          	pop de
0396+  229E C1          	pop bc
0397+  229F F1          	pop af
0398+  22A0 C9          	ret
0337   22A1             
0338   22A1             
0339   22A1             
0340   22A1             
0341   22A1             	.end
0342   22A1             
tasm: Number of errors = 0
