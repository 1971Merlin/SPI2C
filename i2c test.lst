0001   0000             ; -----------------------------------------------------------------------------------------------
0002   0000             ;
0003   0000             ;	Test code for TEC SPI2C board with MAX7219, DS1307 RTC
0004   0000             ;
0005   0000             ;	Uses a MAX7219 8-digit, 7-segment display; Duinotech XC-3714 or equivilant
0006   0000             ;	Uses a DS1307 RTC board; Duinotech XC-4450 or equivilant
0007   0000             ;
0008   0000             ;	Designed to compile for the TEC-1 or SC-1 as the target machine
0009   0000             ;
0010   0000             ;	Assemble with TASM using the command line options -80 -g0
0011   0000             ;
0012   0000             ;	Copyright (C) 2022, Craig Hart. Distributed under the GPLv3 license
0013   0000             ;
0014   0000             ;	https://github.com/1971Merlin/SPI2C
0015   0000             ;
0016   0000             ; -----------------------------------------------------------------------------------------------
0017   0000             
0018   0000             
0019   0000             
0020   0000             
0021   0000             ; ----------------------------------------------------------------------------
0022   0000             ; define global constants to the compiler
0023   0000             ; ----------------------------------------------------------------------------
0024   0000             
0025   0000             ds1307	.equ	68h
0026   0000             lc16b	.equ	0a0h
0027   0000             
0028   0000             
0029   0000             ; ----------------------------------------------------------------------------
0030   0000             ; conditional defines - set the target machine platform
0031   0000             ; comment or un-commnt the following two lines to compile for target machine
0032   0000             ; ----------------------------------------------------------------------------
0033   0000             
0034   0000             #define SC1
0035   0000             ;#define TEC1
0036   0000             
0037   0000             
0038   0000             #ifdef SC1
0039   0000             
0040   0000             ; using i2cspi's onboard 74ls138 IO ports
0041   0000             i2cport	.equ	40h
0042   0000             spiport	.equ	42h
0043   0000             
0044   0000             ; SC-1 7-seg ports
0045   0000             disscan .equ	85h
0046   0000             disseg	.equ	84h
0047   0000             
0048   0000             ; keyboard port
0049   0000             keyport	.equ	86h
0050   0000             
0051   0000             ; start address for SC-1 code
0052   2000             	.org 2000h
0053   2000             
0054   2000             #endif
0055   2000             
0056   2000             
0057   2000             
0058   2000~            #ifdef TEC1
0059   2000~            
0060   2000~            ; using TEC's 74ls138 IO ports
0061   2000~            i2cport	.equ	06h
0062   2000~            spiport	.equ	07h
0063   2000~            
0064   2000~            ; tec-1 7-seg ports
0065   2000~            disscan	.equ	01h
0066   2000~            disseg	.equ	02h
0067   2000~            
0068   2000~            ; keyboard port
0069   2000~            keyport	.equ	00h
0070   2000~            
0071   2000~            
0072   2000~            ; start address for TEC code
0073   2000~            	.org 0900h
0074   2000~            
0075   2000             #endif
0076   2000             
0077   2000             ; ----------------------------------------------------------------------------
0078   2000             ; hardware initialization code starts here
0079   2000             ; ----------------------------------------------------------------------------
0080   2000             
0081   2000             ; reset i2c bus to idle state
0082   2000 3E 03       	ld a,03h	; idle state = SCL and SDA both high
0083   2002 0E 40       	ld c,i2cport
0084   2004 ED 79       	out (c),a
0085   2006             
0086   2006             ; reset spi bus to idle state
0087   2006 0E 42       	ld c,spiport	; reset CS = 1
0088   2008 3E FC       	ld a,0fch	; Raise CS
0089   200A ED 79       	out (c),a
0090   200C CD 58 20    	call ldelay	; pause to establish stable state
0091   200F             
0092   200F             ; init SPI 7-seg dispay to required operational mode
0093   200F 11 FF 09    	ld de,09ffh	; decode mode digits 7-0
0094   2012 CD 31 21    	call spi_wr
0095   2015 11 0F 0A    	ld de,0a0fh	; max brightness
0096   2018 CD 31 21    	call spi_wr
0097   201B 11 07 0B    	ld de,0b07h	; all 8 digits on
0098   201E CD 31 21    	call spi_wr
0099   2021 11 01 0C    	ld de,0c01h	; normal op
0100   2024 CD 31 21    	call spi_wr
0101   2027             
0102   2027             
0103   2027             ; ----------------------------------------------------------------------------
0104   2027             ; main program loop
0105   2027             ; read the clock from the i2c bus
0106   2027             ; display the clock on the internal 7-seg's (for testing!)
0107   2027             ; display the clock also on the i2c 7-seg module
0108   2027             ; ----------------------------------------------------------------------------
0109   2027             
0110   2027             loop:
0111   2027             
0112   2027 CD 66 21    	call rd1307	; Read DS1387 registers
0113   202A             
0114   202A CD 84 21    	call convdata	; Convert DS1387 data to TEC format
0115   202D             
0116   202D CD F5 20    	call scan_7seg	; put display buffer contents on internal display
0117   2030             
0118   2030 CD B8 21    	call maxout	; Put display buffer contents on MAX7219 7-segs
0119   2033             
0120   2033 CD 4C 20    	call pollkey	; get a key
0121   2036 FE FF       	cp 0ffh
0122   2038 28 ED       	jr z, loop
0123   203A             
0124   203A             ; OK pressing a key
0125   203A             
0126   203A             
0127   203A 3A D5 21    	ld a,(mode)
0128   203D EE 80       	xor 80h
0129   203F 32 D5 21    	ld (mode),a
0130   2042             
0131   2042 CD 4C 20    loop2	call pollkey	; get a key
0132   2045 FE FF       	cp 0ffh
0133   2047 20 F9       	jr nz, loop2
0134   2049             
0135   2049             
0136   2049             
0137   2049 C3 27 20    	jp loop
0138   204C             
0139   204C             
0140   204C             ; ----------------------------------------------------------------------------
0141   204C             ; poll keyboard
0142   204C             ;
0143   204C             ; returns a=0ffh if no key, otherwise value read
0144   204C             ; ----------------------------------------------------------------------------
0145   204C             
0146   204C             pollkey:
0147   204C DB 86       	in a,(keyport)
0148   204E CB 6F       	bit 5,a
0149   2050 20 03       	jr nz, key
0150   2052 3E FF       	ld a,0ffh
0151   2054 C9          	ret
0152   2055             
0153   2055 E6 1F       key:	and 1fh
0154   2057 C9          	ret
0155   2058             
0156   2058             
0157   2058             
0158   2058             
0159   2058             ; ----------------------------------------------------------------------------
0160   2058             ; General purpose delay loop
0161   2058             ; ----------------------------------------------------------------------------
0162   2058 F5          ldelay:	push af
0163   2059 D5          	push de
0164   205A 11 00 C0    	ld de,0c000h
0165   205D             
0166   205D 1B          linner:	dec de
0167   205E 7A          	ld a,d
0168   205F B3          	or e
0169   2060 20 FB       	jr nz, linner
0170   2062             
0171   2062 D1          	pop de
0172   2063 F1          	pop af
0173   2064 C9          	ret
0174   2065             
0175   2065             
0176   2065             ; ----------------------------------------------------------------------------
0177   2065             ; set the i2c device address onto the i2c bus
0178   2065             ; ----------------------------------------------------------------------------
0179   2065             ; d = i2c address
0180   2065             ; e = address to set register pointer to
0181   2065             
0182   2065             i2c_write:
0183   2065 D5          	push de
0184   2066 CD 85 20    	call i2c_start
0185   2069 CD A3 20    	call i2c_txbyte
0186   206C 53          	ld d,e		; second byte
0187   206D CD A3 20    	call i2c_txbyte
0188   2070 CD 94 20    	call i2c_stop
0189   2073 D1          	pop de
0190   2074 C9          	ret
0191   2075             
0192   2075             
0193   2075             
0194   2075             ; ----------------------------------------------------------------------------
0195   2075             ; read data from the i2c bus; send an address, receive a result
0196   2075             ; ----------------------------------------------------------------------------
0197   2075             
0198   2075             ; d = i2c address, then read data
0199   2075             ; hl = place to store result
0200   2075             
0201   2075             i2c_read:
0202   2075 D5          	push de
0203   2076 CD 85 20    	call i2c_start
0204   2079 CD A3 20    	call i2c_txbyte
0205   207C             
0206   207C CD C9 20    	call i2c_rxbyte
0207   207F 72          	ld (hl),d	; store result
0208   2080             
0209   2080 CD 94 20    	call i2c_stop
0210   2083 D1          	pop de
0211   2084 C9          	ret
0212   2085             
0213   2085             
0214   2085             
0215   2085             ; ----------------------------------------------------------------------------
0216   2085             ; make the i2c bus active
0217   2085             ; ----------------------------------------------------------------------------
0218   2085             
0219   2085             i2c_start:
0220   2085 F5          	push af
0221   2086 C5          	push bc
0222   2087 0E 40       	ld c,i2cport
0223   2089 3E 02       	ld a,02h	; SCL 1, SDA 0
0224   208B ED 79       	out (c),a
0225   208D 3E 00       	ld a,00h
0226   208F ED 79       	out (c),a	; SCL 0, ADA 0
0227   2091 C1          	pop bc
0228   2092 F1          	pop af
0229   2093 C9          	ret
0230   2094             
0231   2094             ; ----------------------------------------------------------------------------
0232   2094             ; return i2c bus to idle
0233   2094             ; ----------------------------------------------------------------------------
0234   2094             
0235   2094             i2c_stop:
0236   2094 F5          	push af
0237   2095 C5          	push bc
0238   2096 0E 40       	ld c,i2cport
0239   2098 3E 01       	ld a,01h	; SCL 0, SDA 1
0240   209A ED 79       	out (c),a
0241   209C 3E 03       	ld a,03h
0242   209E ED 79       	out (c),a	; SCL 1, ADA 1
0243   20A0 C1          	pop bc
0244   20A1 F1          	pop af
0245   20A2 C9          	ret
0246   20A3             
0247   20A3             
0248   20A3             ; ----------------------------------------------------------------------------
0249   20A3             ; transmit a byte on the i2c bus
0250   20A3             ;
0251   20A3             ; enter  d = byte to send
0252   20A3             ; return d = result
0253   20A3             ; ----------------------------------------------------------------------------
0254   20A3             
0255   20A3             
0256   20A3             i2c_txbyte:
0257   20A3             
0258   20A3 F5          	push af
0259   20A4 C5          	push bc
0260   20A5             
0261   20A5 0E 40       	ld c,i2cport
0262   20A7 06 08       	ld b,8		; 8 bits
0263   20A9             
0264   20A9             txbyte1:
0265   20A9 3E 00       	ld a,00h	; prep CL=low, data = high
0266   20AB CB 02       	rlc d		; set CF = data
0267   20AD 8F          	adc a,a		; set bit 0 to our data
0268   20AE ED 79       	out (c),a	; SDA=data, SCL = 0
0269   20B0             
0270   20B0 CB CF       	set 1,a		; Pulse SCL high
0271   20B2 ED 79       	out (c),a
0272   20B4 CB 8F       	res 1,a
0273   20B6 ED 79       	out (c),a
0274   20B8             
0275   20B8 05          	dec b
0276   20B9 20 EE       	jr nz, txbyte1
0277   20BB             
0278   20BB             ; get ACK since we did a set address command -- if the device is there we should get an answer bit = 0
0279   20BB             
0280   20BB 3E 03       	ld a,03h	; SET SCL = 1 (leave data high == bus free for response)
0281   20BD ED 79       	out (c),a
0282   20BF ED 78       	in a,(c)	;get result; 0 = response received
0283   20C1 57          	ld d,a		; store d=result
0284   20C2 3E 01       	ld a,01h	; SCL = 0, SDA = 1
0285   20C4 ED 79       	out (c),a
0286   20C6             
0287   20C6 C1          	pop bc
0288   20C7 F1          	pop af
0289   20C8 C9          	ret
0290   20C9             
0291   20C9             
0292   20C9             ; ----------------------------------------------------------------------------
0293   20C9             ; receive a byte from the i2c bus
0294   20C9             ;
0295   20C9             ; return d = result
0296   20C9             ; ----------------------------------------------------------------------------
0297   20C9             
0298   20C9             i2c_rxbyte:
0299   20C9             
0300   20C9 F5          	push af
0301   20CA C5          	push bc
0302   20CB             
0303   20CB 0E 40       	ld c,i2cport
0304   20CD 06 08       	ld b,8		; 8 bits
0305   20CF 16 00       	ld d,00h	; (our data to be read)
0306   20D1             
0307   20D1             
0308   20D1             rxbyte1:
0309   20D1 3E 01       	ld a,01h	; prep SCL=low, data = high (tristate output)
0310   20D3 ED 79       	out (c),a	; SDA=data, SCL = 0
0311   20D5             
0312   20D5 3E 03       	ld a,03h	; SCL = 1, SDA = 1
0313   20D7 ED 79       	out (c),a
0314   20D9             
0315   20D9 ED 78       	in a,(c)	; read bit (they send us SDA)
0316   20DB CB 0F       	rrc a		; store into CF
0317   20DD CB 12       	rl d		; and read into d
0318   20DF             
0319   20DF 3E 01       	ld a,01h
0320   20E1 ED 79       	out (c),a	; SCL = 0, SDA = 1 (tristate output)
0321   20E3             
0322   20E3 05          	dec b
0323   20E4 20 EB       	jr nz, rxbyte1
0324   20E6             
0325   20E6             ; send aCK since we read a byte
0326   20E6             
0327   20E6             
0328   20E6 3E 01       ack:	ld a,01h	; Send ACL pulse clock with D=1
0329   20E8 ED 79       	out (c),a
0330   20EA 3E 03       	ld a,03h	; SCL = 1, SDA = 1
0331   20EC ED 79       	out (c),a
0332   20EE 3E 01       	ld a,01h	; lower SCL
0333   20F0 ED 79       	out (c),a
0334   20F2             
0335   20F2 C1          	pop bc
0336   20F3 F1          	pop af
0337   20F4 C9          	ret
0338   20F5             
0339   20F5             
0340   20F5             ; ----------------------------------------------------------------------------
0341   20F5             ; utility routine to scan the internal 7-seg displays
0342   20F5             ; ----------------------------------------------------------------------------
0343   20F5             
0344   20F5             scan_7seg:
0345   20F5 F5          	push af
0346   20F6 C5          	push bc
0347   20F7 E5          	push hl
0348   20F8             
0349   20F8             outerloop:
0350   20F8 0E 20       	ld c,020h
0351   20FA 21 CD 21    	ld hl,disp_buff
0352   20FD 23          	inc hl
0353   20FE             
0354   20FE             scanloop:
0355   20FE 7E          	ld a,(hl)	; output value
0356   20FF CD 22 21    	call conv7seg
0357   2102 D3 84       	out (disseg),a
0358   2104 79          	ld a,c		; turn on display
0359   2105 D3 85       	out (disscan),a
0360   2107 06 C0       	ld b,0c0h
0361   2109 10 FE       on:	djnz on
0362   210B             
0363   210B 3E 00       	ld a,00h	; turn off display
0364   210D D3 85       	out (disscan),a
0365   210F 06 18       	ld b,18h
0366   2111 10 FE       off:	djnz off
0367   2113             
0368   2113 23          	inc hl
0369   2114 CB 09       	rrc c
0370   2116 30 E6       	jr nc,scanloop
0371   2118             
0372   2118 3E 00       	ld a,00h	; turn off displays
0373   211A D3 84       	out (disseg),a
0374   211C D3 85       	out (disscan),a
0375   211E             
0376   211E E1          	pop hl
0377   211F C1          	pop bc
0378   2120 F1          	pop af
0379   2121 C9          	ret
0380   2122             
0381   2122             
0382   2122             conv7seg:
0383   2122 C5          	PUSH	BC
0384   2123 E5          	PUSH	HL
0385   2124 21 D6 21    	LD	HL,segs
0386   2127 E6 0F       	AND	0fh	;TO INDEX TO THE
0387   2129 4F          	LD	C,A	;THE SEVEN SEGMENT
0388   212A 06 00       	LD	B,00h	;CODE FOR THAT VALUE
0389   212C 09          	ADD	HL,BC	;AND RETURN WITH
0390   212D 7E          	LD	A,(HL)	;CODE IN A
0391   212E E1          	POP	HL
0392   212F C1          	POP	BC
0393   2130 C9          	RET
0394   2131             
0395   2131             ; ----------------------------------------------------------------------------
0396   2131             ; write to the SPI bus
0397   2131             ;
0398   2131             ; d = command
0399   2131             ; e = data byte
0400   2131             ; ----------------------------------------------------------------------------
0401   2131             
0402   2131 F5          spi_wr:	push af
0403   2132 C5          	push bc
0404   2133 D5          	push de
0405   2134             
0406   2134 0E 42       	ld c,spiport
0407   2136 06 08       	ld b,8
0408   2138             
0409   2138             
0410   2138 3E F8       nbit:	ld a,0f8h	; set 3 lines low
0411   213A CB 02       	rlc d		; next bit into CF
0412   213C 8F          	adc a,a		; Add Data bit 0
0413   213D ED 79       	out (c),a	; set data
0414   213F CB CF       	set 1,a		; set CLK High
0415   2141 ED 79       	out (c),a
0416   2143 3E 00       	ld a,00h	; set cLK low
0417   2145 ED 79       	out (c),a
0418   2147 05          	dec b
0419   2148 20 EE       	jr nz, nbit
0420   214A             
0421   214A 06 08       	ld b,8
0422   214C             
0423   214C 3E 78       nbit2:	ld a,078h
0424   214E CB 03       	rlc e
0425   2150 8F          	adc a,a
0426   2151 ED 79       	out (c),a
0427   2153 CB CF       	set 1,a
0428   2155 ED 79       	out (c),a
0429   2157 3E 00       	ld a,00h
0430   2159 ED 79       	out (c),a
0431   215B 05          	dec b
0432   215C 20 EE       	jr nz, nbit2
0433   215E             
0434   215E             
0435   215E 3E FC       	ld a,0fch	; raise CS
0436   2160 ED 79       	out (c),a
0437   2162             
0438   2162 D1          	pop de
0439   2163 C1          	pop bc
0440   2164 F1          	pop af
0441   2165 C9          	ret
0442   2166             
0443   2166             
0444   2166             ; ----------------------------------------------------------------------------
0445   2166             ; read the DS1307 clock chip
0446   2166             ; ----------------------------------------------------------------------------
0447   2166             
0448   2166             rd1307:
0449   2166 21 C6 21    	ld hl,reg_buffer
0450   2169 06 07       	ld b,7		; 7 bytes to read
0451   216B 1E 00       	ld e,0		; starting from reg 0
0452   216D             
0453   216D             
0454   216D 16 68       lp1307:	ld d,ds1307	; i2c address
0455   216F CB 02       	rlc d		; 7 bits only
0456   2171 CB 82       	res 0,d		; new bit zero = 0 = write
0457   2173 CD 65 20    	call i2c_write
0458   2176             
0459   2176 16 68       	ld d,ds1307	; i2c address
0460   2178 CB 02       	rlc d		; 7 bits only
0461   217A CB C2       	set 0,d		; new bit zero = 1 = read
0462   217C CD 75 20    	call i2c_read
0463   217F             
0464   217F 1C          	inc e
0465   2180 23          	inc hl
0466   2181 10 EA       	djnz lp1307
0467   2183             
0468   2183 C9          	ret
0469   2184             
0470   2184             
0471   2184             
0472   2184             ; ----------------------------------------------------------------------------
0473   2184             ; process the clock chip's raw data into the display buffer format
0474   2184             ; ----------------------------------------------------------------------------
0475   2184             
0476   2184             convdata:
0477   2184 21 C6 21    	ld hl,reg_buffer	; src
0478   2187             
0479   2187 3A D5 21    	ld a,(mode)
0480   218A CB 7F       	bit 7,a
0481   218C             
0482   218C 20 04       	jr nz, conv2
0483   218E             
0484   218E 23          	inc hl			; move to D/M/Y
0485   218F 23          	inc hl
0486   2190 23          	inc hl
0487   2191 23          	inc hl
0488   2192             
0489   2192             
0490   2192             
0491   2192             
0492   2192 11 CD 21    conv2:	ld de,disp_buff		; dest (to be filled right to left)
0493   2195 13          	inc de
0494   2196 13          	inc de
0495   2197 13          	inc de
0496   2198 13          	inc de
0497   2199 13          	inc de
0498   219A 13          	inc de
0499   219B 3E 00       	ld a,00h
0500   219D             
0501   219D             ;secs / date
0502   219D ED 67       	rrd
0503   219F 12          	ld (de),a
0504   21A0 1B          	dec de
0505   21A1 ED 67       	rrd
0506   21A3 12          	ld (de),a
0507   21A4 1B          	dec de
0508   21A5             
0509   21A5             ;mins / month
0510   21A5 23          	inc hl
0511   21A6 ED 67       	rrd
0512   21A8 12          	ld (de),a
0513   21A9 1B          	dec de
0514   21AA ED 67       	rrd
0515   21AC 12          	ld (de),a
0516   21AD 1B          	dec de
0517   21AE             
0518   21AE             ; hours / year
0519   21AE 23          	inc hl
0520   21AF ED 67       	rrd
0521   21B1 12          	ld (de),a
0522   21B2 1B          	dec de
0523   21B3 ED 67       	rrd
0524   21B5 12          	ld (de),a
0525   21B6 1B          	dec de
0526   21B7             
0527   21B7 C9          	ret
0528   21B8             
0529   21B8             
0530   21B8             
0531   21B8             ; ----------------------------------------------------------------------------
0532   21B8             ; Send the contents of the display buffer to the MAX7219 chip
0533   21B8             ; ----------------------------------------------------------------------------
0534   21B8             
0535   21B8 21 CD 21    maxout:	ld hl,disp_buff
0536   21BB 16 08       	ld d,8
0537   21BD             
0538   21BD 5E          lout:	ld e,(hl)
0539   21BE CD 31 21    	call spi_wr
0540   21C1 23          	inc hl
0541   21C2 15          	dec d
0542   21C3 20 F8       	jr nz, lout
0543   21C5             
0544   21C5 C9          	ret
0545   21C6             
0546   21C6             
0547   21C6             
0548   21C6             
0549   21C6             ; ----------------------------------------------------------------------------
0550   21C6             ;	data, variables, etc.
0551   21C6             ; ----------------------------------------------------------------------------
0552   21C6             
0553   21C6             reg_buffer:
0554   21C6 00          	.db 00h
0555   21C7 00          	.db 00h
0556   21C8 00          	.db 00h
0557   21C9 00          	.db 00h
0558   21CA 00          	.db 00h
0559   21CB 00          	.db 00h
0560   21CC 00          	.db 00h
0561   21CD             
0562   21CD             disp_buff:
0563   21CD 0F          	.db 0fh
0564   21CE 0F          	.db 0fh
0565   21CF 0F          	.db 0fh
0566   21D0 0F          	.db 0fh
0567   21D1 0F          	.db 0fh
0568   21D2 0F          	.db 0fh
0569   21D3 0F          	.db 0fh
0570   21D4 0F          	.db 0fh
0571   21D5             
0572   21D5 80          mode:	.db 80h
0573   21D6             
0574   21D6             #ifdef SC1
0575   21D6             segs:
0576   21D6 3F          	.db 3fh
0577   21D7 06          	.db 06h
0578   21D8 5B          	.db 5bh
0579   21D9 4F          	.db 4fh
0580   21DA 66          	.db 66h
0581   21DB 6D          	.db 6dh
0582   21DC 7D          	.db 7dh
0583   21DD 07          	.db 07h
0584   21DE 7F          	.db 7fh
0585   21DF 6F          	.db 6fh
0586   21E0             #endif
0587   21E0             
0588   21E0             
0589   21E0~            #ifdef TEC1
0590   21E0~            segs:
0591   21E0~            	.db ebh
0592   21E0~            	.db 28h
0593   21E0~            	.db cdh
0594   21E0~            	.db adh
0595   21E0~            	.db 2eh
0596   21E0~            	.db a7h
0597   21E0~            	.db e7h
0598   21E0~            	.db 29h
0599   21E0~            	.db efh
0600   21E0~            	.db 2fh
0601   21E0             #endif
0602   21E0             
0603   21E0             
0604   21E0             ; ----------------------------------------------------------------------------
0605   21E0             ; end of our code and data, end of program. goodbye!
0606   21E0             ; ----------------------------------------------------------------------------
0607   21E0             
0608   21E0             	.end
tasm: Number of errors = 0
